// Copyright (c) Microsoft. All rights reserved.
// Licensed under the MIT license. See LICENSE file in the project root for full license information.

import {Artifact, Cmd, Transformer, Tool} from "Sdk.Transformers";
import * as Json from "Sdk.Json";

@@public
export const guardianTag = "msguardian";

/** Environment Variables */
export const guardianDisableFlag = "[Tool.Guardian]disable";
export const guardianWarnOnlyFlag = "[Tool.Guardian]warnOnly";
export const guardianBaselineSuppressionDirectory = "[Tool.Guardian]baselineSuppressDir";
export const guardianGenerateBaselines = "[Tool.Guardian]genBaseline";
export const guardianGenerateSuppressions = "[Tool.Guardian]genSuppressions";

const guardianInstallMutex = "BuildXL.Tools.Guardian.Install.Phase";
const guardianExecutableName : PathAtom = PathAtom.create("guardian.cmd");
const defaultGuardianToolWorkingDirectory = d`${Context.getMount("SourceRoot").path}`;

const cloudbuildToolPath : Directory = Environment.hasVariable("TOOLPATH_GUARDIAN") ? d`${Environment.getDirectoryValue("TOOLPATH_GUARDIAN")}` : undefined;
const cloudBuildDotNetDirectory = cloudbuildToolPath ? d`${cloudbuildToolPath}/dotnetX64` : undefined;
const cloudBuildTempDirectory = cloudbuildToolPath ? d`${cloudbuildToolPath.parent.parent.path}/temp` : undefined;

const guardianUntrackedDirectories = addIfLazy(Context.getCurrentHost().os === "win", () => [
    // Accessed by the Guardian CLI
    d`${Context.getMount("ProgramFilesX86").path}/dotnet`,
    d`${Context.getMount("ProgramFiles").path}/dotnet`,
    ...addIf(cloudBuildDotNetDirectory !== undefined, cloudBuildDotNetDirectory),
    d`${Context.getMount("ProgramData").path}/Microsoft/NetFramework`,
    d`${Context.getMount("ProgramData").path}/Microsoft/VisualStudio/Setup`,
    // Config files accessed by nuget during Guardian install phase
    d`${Context.getMount("ProgramFilesX86").path}/Nuget`,
    d`${Context.getMount("ProgramFiles").path}/Nuget`,
    d`${Context.getMount("LocalLow").path}/Microsoft/CryptnetUrlCache`,
    // Nuget artifacts credential provider
    d`${Context.getMount("UserProfile").path}/.nuget/plugins/netfx/CredentialProvider.Microsoft`,
    d`${Context.getMount("UserProfile").path}/.nuget/plugins/netcore/CredentialProvider.Microsoft`,
    // Nuget will cache packages under ~/.nuget/packages, however they will always get copied over to the package install directory
    // Since we track the package install directory, we will untrack the ~/.nuget/packages directory.
    d`${Context.getMount("UserProfile").path}/.nuget/packages`,
    // Guardian occasionally does not honour the TMP/TEMP variables, and instead will write temp files to other locations listed below
    // The temp directory on cloudbuild will always be created under X:\a\b\temp, when the cloudbuild drop is at X:\a\b\c\d (this location is not expected to change between builds)
    // TODO: Remove this line once the Guardian team fixes this bug to use the temp directory specified in TEMP/TMP instead.
    ...addIf(cloudBuildTempDirectory !== undefined, cloudBuildTempDirectory),
]);

/**
 * Tool definition for guardian
 * Note: Package root is untracked because we rely on the .gdn/c directory to know when a new Guardian tool is available.
 */
function getGuardianTool(args: GuardianArguments, guardianPaths : GuardianPaths) : Transformer.ToolDefinition {
    return {
        exe: findGuardianExecutable(args.guardianToolRootDirectory),
        description: "Microsoft Guardian",
        dependsOnWindowsDirectories: true,
        dependsOnAppDataDirectory: true,
        prepareTempDirectory: true,
        untrackedDirectoryScopes: [
            ...guardianUntrackedDirectories,
            // When using the integrated Guardian package (such as the one on CloudBuild), Guardian may write under these paths even though it has a temporary directory prepared.
            d`${args.guardianToolRootDirectory.path}/temp`,
            d`${args.guardianToolRootDirectory.path}/tmp`,
            ...addIf(args.autoGeneratedBaselineSuppressionLocation !== undefined, args.autoGeneratedBaselineSuppressionLocation),
        ],
        // Untracking localRepo/.gdnhistory to ignore double writes between guardian init and guardian run
        // the history in here is not important because each Guardian call gets it's own .gdnhistory file.
        // globalRepo/.gdnhistory will also be read from, but it will not be written to.
        untrackedFiles: [ f`${guardianPaths.localHistory}`, f`${guardianPaths.globalHistory}` ]
    };
}

/**
 * Find a path to the guardian.cmd script given a static directory.
 */
function findGuardianExecutable(guardianRoot : StaticDirectory) : File {
    // The guardian.cmd script will be under guardianRoot/tools/guardian.cmd for the standalone nuget package, or
    // guardianRoot/guardian.cmd for the Guardian integrated install method.

    Contract.assert(guardianRoot.kind === "full" || guardianRoot.kind === "partial", "Guardian root must either be partially or fully sealed.");

    return guardianRoot.hasFile(r`tools/${guardianExecutableName}`)
        ? guardianRoot.getFile(r`tools/${guardianExecutableName}`)
        : guardianRoot.getFile(guardianExecutableName);
}

/**
 * Schedules a guardian pip with the specified arguments. The install step can be skipped when a package cache is available using the skipInstall option.
 * 
 * Guardian is currently only supported on Windows.
 * 
 * Guardian Lifecycle:
 * - The "guardian run" command is several different Guardian commands run at once by the Guardian process.
 * - These are split up here instead of a single call because some parts are not able to execute concurrently.
 * 
 *  1. guardian init: Initializes a local .gdn directory - can be executed concurrently with other guardian calls.
 *  2. guardian install: Installs packages specified in config file - *can not* be executed concurrently.
 *      NOTE: acquires mutex: guardianInstallMutex
 *  3. guardian run: This call includes the --no-install flag, which allows BuildXL to run it concurrently. It has the following sub-phases:
 *      a. guardian clear: clears results directories
 *      b. guardian analyze: Runs analysis tools and stores raw data in .gdn/.r directory
 *      c. guardian process: Processes the data collected in the previous step into .gdn/r directory
 *      d. guardian break: Look at processed data from previous step, return bad exit code if breaking results found and export results to file.
 */
@@public
export function runGuardian(args: GuardianArguments) : Transformer.ExecuteResult {
    validateArguments(args);

    let guardianResult = undefined;

    if (Environment.getFlag(guardianDisableFlag)) {
        guardianResult = runGuardianNoOp(args);
    }
    else {
        const outputDirectory = Context.getNewOutputDirectory("guardianOut");
        const guardianPaths = createGuardianPaths(outputDirectory, args.guardianPackageDirectory.root);
        const guardianTool = getGuardianTool(args, guardianPaths);
        let guardianDependencies : Transformer.InputArtifact[] = [
            args.guardianToolRootDirectory,
            f`${guardianPaths.globalGuardianRepo}`,
            ...args.guardianConfigFiles,
            ...addIfLazy(args.additionalDependencies !== undefined, () => args.additionalDependencies),
            args.guardianPackageDirectory
        ];

        // TODO: remove workaround for policy packages
        const policyMicrosoft = generateGuardianWorkaroundPackageFile(guardianPaths.microsoftDefaultPolicyPackageConfig, "Microsoft.Security.CodeAnalysis.Policy.Microsoft.Internal");
        const policyNames = generateGuardianWorkaroundPackageFile(guardianPaths.policyNamesPackageConfig, "Microsoft.Security.CodeAnalysis.Policy.Names.Internal");
    
        // 1. Initialize Guardian for this Guardian run
        //      - Settings files from previous step not necessary here, can be run concurrently with the WriteFile operation.
        const initializeResult = initializeGuardian(args, guardianTool, guardianPaths, guardianDependencies);

        // Steps below this depend on the results of step 0 and step 1
        guardianDependencies = guardianDependencies.concat([
            f`${guardianPaths.globalSettings}`,
            initializeResult.getOutputDirectory(d`${guardianPaths.localGuardianRepo}`),
            policyMicrosoft,
            policyNames
        ]);

        switch (args.guardianCommand) {
            case "Install":
                // Generate a settings file for the install operation.
                const installSettingsFile = generateGuardianInstallSettingsFile(guardianPaths);

                // The output of the Guardian run execute call will contain a sealed directory that can be passed to the next guardian run call.
                guardianResult = runGuardianInstallInternal(args, guardianTool, installSettingsFile, guardianDependencies, guardianPaths);
                break;
            case "Run":
                // Create a Guardian settings
                const genericSettingsFile = generateGenericGuardianSettingsFile(guardianPaths);
                        
                // 3. Guardian run to run static analysis tools specified in config file, break build if any breaking changes are found, and export results.
                guardianDependencies = guardianDependencies.push(genericSettingsFile);
                guardianResult = runGuardianInternal(args, guardianTool, genericSettingsFile, guardianDependencies, guardianPaths);
                break;
            default:
                Contract.fail(`Unsupported Guardian command '${args.guardianCommand}'.`);
        }
    }
    
    return guardianResult;
}

/**
 * Validates that all required arguments are provided, and no conflicting arguments are set.
 */
function validateArguments(args: GuardianArguments) : void {
    Contract.requires(args !== undefined, "Guardian arguments cannot be undefined.");
    Contract.requires(args.guardianCommand !== undefined, "Guardian command must be specified.");
    Contract.requires(args.guardianToolRootDirectory !== undefined, "Guardian root must be set.");
    Contract.requires(args.guardianConfigFiles !== undefined, "Guardian config file must be set.");
    Contract.requires(args.guardianResultFile !== undefined, "Guardian output file must be set.");
    Contract.requires(args.guardianPackageDirectory !== undefined, "Guardian tool package install directory must be set.");
    Contract.requires(args.filesToBeScanned !== undefined, "Files to be scanned by Guardian must be set.");

    if (args.fast && args.baselineFiles) {
        Contract.fail("The --fast argument is incompatible with the output baseline file argument, as this will require a full run of guardian break to generate all the results.");
    }

    if (args.noBaseline && args.baselineFiles) {
        Contract.fail("noBaseline and baselineFile cannot be specified together.");
    }

    if (args.noSuppressions && (args.suppressionFiles || args.suppressionSets)) {
        Contract.fail("noSuppressions and suppressionFiles/suppressionSets cannot be specified together.");
    }
}

/**
 * Creates a no-op for when the disable flag is set to 1 to skip running Guardian.
 */
function runGuardianNoOp(args : GuardianArguments) : Transformer.ExecuteResult {
    const cmdTool: Transformer.ToolDefinition = {
        exe: f`${Environment.getPathValue("COMSPEC")}`,
        dependsOnWindowsDirectories: true,
        prepareTempDirectory: true
    };

    return Transformer.execute({
        tool: cmdTool,
        arguments: [Cmd.argument("/D /C exit 0")],
        dependencies: [],
        outputs: [{ existence: "optional", artifact: f`${args.guardianResultFile.path}` }],
        workingDirectory: d`${args.guardianResultFile.parent}`,
        description: "Guardian No-op"
    });
}

/**
 * Generates a set of paths that are produced/consumed by Guardian based on a generated output directory
 * and user specified package install directory.
 */
function createGuardianPaths(outputDirectory : Directory, packageDirectory : Directory) : GuardianPaths {
    return { 
        globalGuardianRepo: p`${Context.getMount("SourceRoot").path}/.gdn`,
        localGuardianRepo: p`${outputDirectory}/.gdn`,
        config: p`${outputDirectory}/.gdn/c`,
        rawResults: p`${outputDirectory}/.r`,
        results: p`${outputDirectory}/r`,
        convertedResults: p`${outputDirectory}/rc`,
        install: p`${packageDirectory}`,
        localSettings: p`${outputDirectory}/buildxl.gdnsettings`,
        localInstallSettings: p`${outputDirectory}/buildxl_install.gdnsettings`,
        globalSettings: p`${Context.getMount("SourceRoot").path}/.gdn/.gdnsettings`,
        localHistory: p`${outputDirectory}/.gdn/internal.gdnhistory`,
        globalHistory: p`${Context.getMount("SourceRoot").path}/.gdn/internal.gdnhistory`,
        installLog: f`${outputDirectory}/install`,
        policyNamesPackageConfig: p`${outputDirectory}/buildxl_policy_names.gdnpackage`,
        microsoftDefaultPolicyPackageConfig: p`${outputDirectory}/buildxl_policy_microsoft.gdnpackage`,
    };
}

/**
 * Generates a Guardian configuration using specified paths.
 */
function generateGenericGuardianSettingsFile(guardianPaths : GuardianPaths) : File {
    const settings = {
        folders: {
            GuardianRepo: guardianPaths.localGuardianRepo,
            Config: guardianPaths.config,
            RawResults: guardianPaths.rawResults,
            Results: guardianPaths.results,
            ConvertedResults: guardianPaths.convertedResults,
            Install: guardianPaths.install
        }
    };

    return generateGuardianSettingsFile(guardianPaths.localSettings, settings, "Generate generic Guardian settings file");
}

/**
 * Generates a config file for Guardian install step. This requires a separate settings file without config, raw results, results, or converted results directories set
 * so that it uses the local .gdn repo.
 */
function generateGuardianInstallSettingsFile(guardianPaths : GuardianPaths) : File {
    const settings = {
        folders: {
            GuardianRepo: guardianPaths.localGuardianRepo,
            Install: guardianPaths.install
        }
    };
    
    return generateGuardianSettingsFile(guardianPaths.localInstallSettings, settings, "Generate Guardian install settings file");
}

/**
 * Generates a package config to workaround policy files not being installed with Guardian install.
 * 
 * TODO: Delete this function when Guardian bug 49258 is resolved
 */
function generateGuardianWorkaroundPackageFile(policyFilePath: Path, packageName : string) : File {
    const packageConfig = {
        type: "nuget",
        name: packageName,
        sources: [
            {
                name: "Guardian.Policy@Local",
                value: "https://securitytools.pkgs.visualstudio.com/_packaging/Guardian.Policy%40Local/nuget/v3/index.json"
            }
        ]
    };

    return generateGuardianSettingsFile(policyFilePath, packageConfig, "Generate Guardian install policy file");
}

/**
 * Call Json SDK to write settings file.
 */
function generateGuardianSettingsFile(outputPath : Path, settings : Object, description : string) : File {
    const options : Json.AdditionalJsonOptions = {
        pathRenderingOption: Context.getCurrentHost().os !== "win" ? "escapedBackSlashes" : "forwardSlashes"
    };

    return Json.write(outputPath, settings, "\"", [guardianTag], description, options);
}

/**
 * Initialize Guardian under a new output directory for this run. This will allow BuildXL to isolate each Guardian call into it's own repository.
 */
function initializeGuardian(args : GuardianArguments, guardianTool : Transformer.ToolDefinition, guardianPaths : GuardianPaths, guardianDependencies : Transformer.InputArtifact[]) : Transformer.ExecuteResult {
    const arguments : Argument[] = [
        Cmd.argument("init"),
        Cmd.argument("--force"),
        Cmd.option("--logger-level ", args.logLevel !== undefined ? args.logLevel.toString() : undefined)
    ];
    
    return Transformer.execute({
        tool: guardianTool,
        tags: [ guardianTag ],
        arguments: arguments,
        workingDirectory: d`${guardianPaths.localGuardianRepo.parent}`,
        dependencies: guardianDependencies,
        outputs: [ d`${guardianPaths.localGuardianRepo}` ],
        successExitCodes: getSuccessExitCodes(),
        warningRegex: getWarningRegex(),
        description: `Guardian Initialize: ${args.guardianConfigFiles.map(file => file.name.toString()).join(",")}`,
        environmentVariables: getEnvironmentVariables(args)
    });
}

/**
 * Runs the "guardian install" command for the tools specified by the user
 * Packages will be installed under guardianPaths.install
 * This step requires a mutex as multiple Guardian calls may try to install at the same time to the same directory.
 */
function runGuardianInstallInternal(args : GuardianArguments, guardianTool : Transformer.ToolDefinition, settingsFile : File, guardianDependencies : Transformer.InputArtifact[], guardianPaths : GuardianPaths) : Transformer.ExecuteResult {
    const arguments : Argument[] = [
        Cmd.argument("install"),
        Cmd.option("--settings-file ", settingsFile.path),
        Cmd.option("--logger-filepath ", guardianPaths.installLog.path),
        Cmd.option("--logger-level ", args.logLevel !== undefined ? args.logLevel.toString() : undefined),
        Cmd.flag("no-policy", args.noPolicy),
        Cmd.option("--config ", Cmd.join(" ", args.guardianConfigFiles.map(file => file.path))),
        /** TODO: Remove this option */
        //Cmd.option("--package-config ", Cmd.join(" ", [guardianPaths.policyNamesPackageConfig, guardianPaths.microsoftDefaultPolicyPackageConfig]))
    ];

    guardianDependencies = guardianDependencies.push(settingsFile);

    return Transformer.execute({
        tool: guardianTool,
        tags: [ guardianTag ],
        arguments: arguments,
        workingDirectory: d`${guardianPaths.localGuardianRepo.parent}`,
        dependencies: guardianDependencies,
        outputs: [ guardianPaths.installLog, {kind: "shared", directory: d`${guardianPaths.install}`} ],
        acquireMutexes: [ guardianInstallMutex ],
        successExitCodes: getSuccessExitCodes(),
        warningRegex: getWarningRegex(),
        description: `Guardian Install: ${args.guardianConfigFiles.map(file => file.name.toString()).join(",")}`,
        environmentVariables: getEnvironmentVariables(args),
        unsafe: {
            untrackedPaths: args.untrackedPaths,
            untrackedScopes: args.untrackedScopes
        }
    });
}

/**
 * Performs a Guardian run operation. Uses the --no-install argument to skip installing, since this was already done in a previous call.
 * See block comment on the runGuardian function to see which steps this call will perform.
 */
function runGuardianInternal(args : GuardianArguments, guardianTool : Transformer.ToolDefinition, settingsFile : File, guardianDependencies : Transformer.InputArtifact[], guardianPaths : GuardianPaths) : Transformer.ExecuteResult {
    const arguments: Argument[] = [
        Cmd.argument("run"),
        Cmd.argument("--no-install"),
        Cmd.option("--settings-file ", settingsFile.path),
        Cmd.option("--config ", Cmd.join(" ", args.guardianConfigFiles.map(file => file.path))),
        Cmd.option("--export-breaking-results-to-file ", args.guardianResultFile.path),
        Cmd.option("--logger-filepath ", args.loggerPath && args.loggerPath.path),
        Cmd.flag("--analyze-fast", args.fast),
        Cmd.flag("--no-baseline", args.noBaseline),
        Cmd.option("--baseline-file ", Cmd.join(" ", args.baselineFiles && args.baselineFiles.map(e => e.path))),
        Cmd.flag("--no-suppressions", args.noSuppressions),
        Cmd.option("--suppression-file ", Cmd.join(" ", args.suppressionFiles && args.suppressionFiles.map(e => e.path))),
        Cmd.options("--suppression-set ", args.suppressionSets),
        Cmd.flag("no-policy", args.noPolicy),
        Cmd.option("--policy ", args.policy),
        Cmd.option("--logger-level ", args.logLevel !== undefined ? args.logLevel.toString() : undefined),
        ...getBaselineOrSuppressOptions(args),
    ];

    // Dependencies
    guardianDependencies = guardianDependencies.concat(args.filesToBeScanned);
    
    if (args.baselineFiles) {
        guardianDependencies = guardianDependencies.concat(args.baselineFiles);
    }

    if (args.suppressionFiles) {
        guardianDependencies = guardianDependencies.concat(args.suppressionFiles);
    }
    
    // Outputs
    // If no errors are generated, then no output file will be generated.
    const maybeExportFile : Transformer.FileOrPathOutput = { existence: "optional", artifact: f`${args.guardianResultFile.path}` };

    // Log file only generated if caller sets args.loggerPath
    const maybeLogFile : Transformer.FileOrPathOutput = args.loggerPath
        ? { existence: "optional", artifact: f`${args.loggerPath.path}` }
        : undefined;

    let outputs : Transformer.Output[] = [
        maybeExportFile,
        d`${guardianPaths.rawResults}`,
        d`${guardianPaths.results}`,
        d`${guardianPaths.convertedResults}`,
        ...addIfLazy(args.additionalOutputs !== undefined, () => args.additionalOutputs)
    ];

    if (maybeLogFile) {
        outputs = outputs.push(maybeLogFile);
    }

    // Run Guardian
    const result : Transformer.ExecuteResult = Transformer.execute({
        tool: guardianTool,
        tags: [guardianTag],
        arguments: arguments,
        workingDirectory: args.guardianToolWorkingDirectory ? args.guardianToolWorkingDirectory : defaultGuardianToolWorkingDirectory,
        dependencies: guardianDependencies,
        outputs: outputs,
        successExitCodes: getSuccessExitCodes(),
        warningRegex: getWarningRegex(),
        description: `Guardian Run: ${args.guardianConfigFiles.map(file => file.name.toString()).join(",")}`,
        environmentVariables: getEnvironmentVariables(args),
        retryExitCodes: args.retryExitCodes,
        processRetries: args.processRetries,
        unsafe: {
            untrackedPaths: args.untrackedPaths,
            untrackedScopes: args.untrackedScopes
        }
    });

    return result;
}

/**
 * When the warnOnly flag is set, then exit code 1 will be considered a success exit code.
 */
function getSuccessExitCodes() : number[] {
    return Environment.getFlag(guardianWarnOnlyFlag) ? [0, 1] : [0];
}

/**
 * When the warnOnly flag is set, log Guardian errors as warnings using regex.
 */
function getWarningRegex() : string {
    return Environment.getFlag(guardianWarnOnlyFlag) ? "\\[Error\\].*" : undefined;
}

/**
 * Merges cloudbuild and user specified environment variables.
 */
function getEnvironmentVariables(args : GuardianArguments) : Transformer.EnvironmentVariable[] {
    const cbEnvVars = getCloudbuildEnvironmentVariables(args);

    return args.environmentVariables === undefined
        ? cbEnvVars
        : args.environmentVariables.concat(cbEnvVars); // Cloudbuild variables should override user provided variables here
}

/**
 * If the TOOLPATH_GUARDIAN environment variable is set, then Guardian should be running on Cloudbuild.
 * Add dotnet to the PATH variable for Guardian calls on Cloudbuild.
 */
function getCloudbuildEnvironmentVariables(args : GuardianArguments) : Transformer.EnvironmentVariable[] {
    if (cloudbuildToolPath) {
        return [
            { name: "PATH", separator: ";", value: [ d`${cloudBuildDotNetDirectory.path}`, ...addIfLazy(args.pathDirectories !== undefined, () => args.pathDirectories) ] },
            { name: "DOTNET_ROOT", separator: ";", value: d`${cloudBuildDotNetDirectory.path}` },
        ];
    }

    return [];
}

/**
 * Special command line options for the guardian run command to automatically generate baselines or suppressions
 * Note that this will disable breaking the build so that all baselines can be generated without the build stopping early due to a failure.
 */
function getBaselineOrSuppressOptions(args : GuardianArguments) : Argument[] {
    if (Environment.getFlag(guardianGenerateBaselines)) {
        return [
            Cmd.argument("--not-break-on-detections"),
            Cmd.option("--output-baseline-file ", p`${args.autoGeneratedBaselineSuppressionLocation.path}/${args.baselineFileName}`),
        ];
    }
    else if (Environment.getFlag(guardianGenerateSuppressions)) {
        return [
            Cmd.argument("--not-break-on-detections"),
            Cmd.option("--output-suppression-file ", p`${args.autoGeneratedBaselineSuppressionLocation.path}/${args.suppressionFileName}`),
        ];
    }

    return [];
}

/**
 * Set of guardian arguments. See notes on each argument for any special considerations that need to be
 * taken before using them.
 */
@@public
export interface GuardianArguments extends Transformer.RunnerArguments {
    /** The Guardian command to be run. */
    guardianCommand: GuardianCommand;
    /** Root directory for Guardian install (contains guardian.cmd)
     ** Note: Guardian will still read/write to this directory for updates to itself
     **       or for tool updates, so this should be partially sealed.
     **
     ** Under the guardian root directory the guardian tool will:
     **  - Get new versions of itself to ./versions/, and run the latest Guardian Cli from here
     **  - Get the latest versions of tools being run under ./packages/
     **  - Read ./.gdnversion to check the current Guardian version to check whether it should be updated
     **  - Potentially write temporary files to ./.tmp/ */
    guardianToolRootDirectory: StaticDirectory;
    /** A configuration file to run with guardian */
    guardianConfigFiles: File[];
    /** Path to export guardian result file
     ** Note: No export file will be generated if guardian executes without any errors. */
    guardianResultFile: File;
    /** Specify where Guardian tool packages will be installed.
     ** If Guardian install was run as part of the build, this must be the sealed directory produced by the run command.
     ** Note: This path can be the .gdn/i directory, but must always be declared so that Guardian does
     **       try to read packages from outside of this location (due to its package cache feature). */
    guardianPackageDirectory: StaticDirectory;
    /** Optional Guardian tool working directory. Default: SourceRoot
     ** Note: the default directory "TargetDirectory" for many tools will be this working directory. */
    guardianToolWorkingDirectory?: Directory;
    /** Collection of files that guardian will be scanning
     ** Note: in many cases (such as with credscan), a user cannot specify which files specifically
     **       to run through the tool, so glob all source files that will be touched by the tool here */
    filesToBeScanned: File[];
    /** Any additional artifacts to depend on before running Guardian in addition to the ones declared in filesToBeScanned */
    additionalDependencies?: Transformer.InputArtifact[];
    /** An optional path to a file to redirect the guardian logger output */
    loggerPath?: File;
    /** Indicate whether Guardian should fail entire job after the first failure
     ** Note: defaults to false */
    fast?: boolean;
    /**  Will not allow the use of any baselines including the default baseline (.gdn/.gdnbaselines)*/
    noBaseline?: boolean;
    /** Absolute paths to optional baseline files */
    baselineFiles?: File[];
    /** Will not allow any suppressions including the default suppression set in .gdn/.gdnsuppress */
    noSuppressions?: boolean;
    /** Absolute paths to optional suppression files */
    suppressionFiles?: File[];
    /** Will use specified suppression set(s) to filter breaking results. Only results in these sets will cause a break */
    suppressionSets?: string[];
    /** Specify policy name (default: microsoft) for break method */
    policy?: string;
    /** For use with policy, set minimum severity as defined by policy to cause a break. Any results below this severity will NOT cause a break. */
    severity?: string;
    /** Do not apply any policy */
    noPolicy?: boolean;
    /** Log level for Guardian to display to stdout */
    logLevel?: GuardianLogLevel;
    /** Environment variables to be passed to Guardian */
    environmentVariables?: Transformer.EnvironmentVariable[];
    /** Location to place automatically generated baselines/suppressions */
    autoGeneratedBaselineSuppressionLocation?: Directory;
    /** Name for automatically generated baseline file */
    baselineFileName?: PathAtom;
    /** Name for automatically generated suppression file */
    suppressionFileName?: PathAtom;
    /** Exit codes to retry if a Guardian tool fails */
    retryExitCodes?: number[];
    /** Maximum number of times to retry if a process fails with any of the codes in retryExitCodes. Can only be used if retryExitCodes is specified. */
    processRetries?: number;
    /** Set of directories to add to the PATH variable for the Guardian call. */
    pathDirectories?: Directory[];
    /** Declare any additional ouputs here that may be generated during a Guardian run. eg: .eslintcache */
    additionalOutputs?: Transformer.Output[];
    /** Paths to be untracked for a Guardian run. */
    untrackedPaths?: (File | Directory)[];
    /** Untracked scopes for a guardian run */
    untrackedScopes?: Directory[]
}

/**
 * Guardian Log levels:
 * 
 * None: (Silent) Do not output any messages, even if they are breaking.
 * Standard: Standard messages intended for the user to see.
 * Verbose: Messages for lower level actions a user may like to see, but are not necessary for them to understand the high level actions of the application.
 * Warning: Non-breaking messages that are of greater importance for the user to see. Note: setting Warning also includes Error.
 * Error: Breaking message that indicate something went wrong.
 * Trace: Messages primarily intended for the application developer or a savy user to debug an application when it faults or gain insight during testing. Messages at this level should not be localized.
 */
@public
export type GuardianLogLevel = "None" | "Standard" | "Verbose" | "Warning" | "Error" | "Trace";

/**
 * Supported Guardian commands by the BuildXL Guardian SDK.
 */
@@public
export type GuardianCommand = "Install" | "Run";

/**
 * Collection of Paths that are produced or consumed by Guardian.
 */
interface GuardianPaths {
    /** SourceRoot/.gdn */
    globalGuardianRepo: Path,
    /** OutputDir/.gdn */
    localGuardianRepo: Path,
    /** localGuardianRepo/c */
    config: Path,
    /** OutputDir/.r */
    rawResults: Path,
    /** OutputDir/r */
    results: Path,
    /** OutputDir/rc */
    convertedResults: Path,
    /** Path to Guardian tool install directory (usually located under .gdn/i or guardianRoot/packages). */
    install: Path,
    /** Path to locally generated Guardian settings file to be used */
    localSettings: Path,
    /** Path to locally generated Guardian settings file to be used only for guardian install. */
    localInstallSettings: Path,
    /** Path to global settings file checked into repository */
    globalSettings: Path,
    /** localGuardianRepo/internal.gdnhistory */
    localHistory: Path,
    /** globalGuardianRepo/internal.gdnhistory */
    globalHistory: Path,
    /** intermediate Guardian install log file. */
    installLog: File,
    /** TODO: Remove these two variables below when Guardian bug 49258 is resolved */
    /** Path to be used for Microsoft.Security.CodeAnalysis.Policy.Names.Internal */
    policyNamesPackageConfig: Path,
    /** Path to be used for Microsoft.Security.CodeAnalysis.Policy.Microsoft.Internal */
    microsoftDefaultPolicyPackageConfig: Path,
}